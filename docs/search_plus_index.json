{"./":{"url":"./","title":"Computer Network Lab Manual","keywords":"","body":"Computer Network Lab Manual Computer Network, Nanjing University, Spring 2020 Course Info Course Number: 22010050 Lecturer: Chen Tian & Wenzhong Li Website: https://cs.nju.edu.cn/lwz/networks-2020/ Contact Course QQ group: 940577165 You can find TAs and our 教学立方 invitation code after joining this group. Lab Assignments Lab -1: Python This is not a lab assignment, but helps you to learn Python. Start the lab here. Lab 0: Switchyard & Mininet Out: , due . Start the lab here. Lab 1: Learning switch Out: , due . Lab 2: IPv4 Router Out: , due . Lab 2a: Respond to ARP Out: , due . Lab 2b: Forwarding packets Out: , due . Lab 2c: Respond to ICMP Out: , due . Lab 3: Reliable Communication Out: , due . Lab 3a: Sender and Router Out: , due . Lab 3b: Receiver Out: , due . Policies We encourage discussions with others to clarify questions about homework problems and programming assignment problem statements. However [!DANGER|style:flat] Programming solutions must be your own. Do not make your remote assignment repository public. "},"content/ch-1/lab--1.html":{"url":"content/ch-1/lab--1.html","title":"Lab -1: Python","keywords":"","body":"Lab -1: Python Switchyard and Mininet are developed in Python. So you need to program in Python (though there are some methods to avoid using Python). Python is an easy-learning language. If you are not familiar with it, here are some materials for you to get started. 廖雪峰的 Python 3 教程 Python 教程 Learn Python - Free Interactive Python Tutorial Our VM is Python preinstalled so you can skip installing. Topics you need to know about Python are listed here Python Interpreter Data Types (Important) Data Structures (Important) Flow Control (Important) Functions (Important) Modules Input and Output Errors and Exceptions Standard Library Virtual Environments and Packages (Important) Except those topics marked as important, it is no need to read it carefully, just program as you learn. We expect that you will cost about 3 days on this if you haven't worked with Python. [!NOTE] Python 3 is the main language you will use in Switchyard programming. But you need to know some difference between Python 3 and Python 2 though they are mostly the same. Because you may write some Mininet topology scripts using Python 2. "},"content/ch00/lab-0.html":{"url":"content/ch00/lab-0.html","title":"Lab 0: Switchyard & Mininet","keywords":"","body":"Lab 0: Switchyard & Mininet Overview In this chapter we will introduce all preparations for our network experiments. Details Our lab assignments are based on CS640 in University of Wisconsin. Most materials are the same. In the future, we will improve the experimantal content based on feedback. For this lab assignment, you will gradually master our experimental environment. But we need you to know some basic skills, such as how to develope on linux or how to program. If you are not familiar with these, please tell TAs. We will list some helpful materials for you to get started quickly. First, you need to complete setting up your enviroment. Read section Prerequisites. Then here are some tutorials help you get started with our experimental environment. How to use Mininet How to use Wireshark How to program in Switchyard "},"content/ch00/prerequisites.html":{"url":"content/ch00/prerequisites.html","title":"Prerequisites","keywords":"","body":"Prerequisites Virtual Machine We are providing you with a Ubuntu 18.04 (64-bit) VM image for this assignment. This image has Switchyard, Mininet and Wireshark installed so you do not need to worry about setting up the enviroment. You can find the VM image here. (user name: njucs - password: 123) You can learn more about importing a VM image in VirtualBox here. You are also free to use your favorite vitualization software for importing the image but you will most probably have to deal with the possible issues on yourself. If you are a free soul and want to setup Switchyard in a different environment you are welcome to do that as well. You can find some useful information here. This might or might not be useful for you depending on your environment. Mininet Mininet enables you to quickly create, interact with, customize and share a software defined network prototype, and provides a smooth path to running on hardware. The most useful material is their website. Here is the Mininet Walkthrough. It is better to go through this manual. Because we have not given you the whole network image to you right now, there must be something you do not understand yet. But don not worry, we will have a small practice of Mininet in our manual. [!NOTE] Ignore the content about switches like Open vSwitch (OVS) setting up. We expect that you will cost 2 days on this. Wireshark Wireshark is the world’s foremost and widely-used network protocol analyzer. It lets you see what’s happening on your network at a microscopic level and is the de facto (and often de jure) standard across many commercial and non-profit enterprises, government agencies, and educational institutions. You will use it to inspect your network setting up by Mininet, and test the function of your device written in Switchyard. We also have a small practice of Wireshark in our manual. Wireshark User’s Guide is a verbose document about Wireshark but We do not recommend it. So sometimes the offical document is hard for user to get started. You can find many blogs writing about how to use Wireshark. Read them instead or the first search result in Google here. We expect that you will cost an afternoon on this. Switchyard Switchyard is a framework for creating, testing, and experimenting with software implementations of networked systems such as Ethernet switches, IP routers, firewalls and middleboxes, and end-host protocol stacks. It is the framework targeting on teaching and used in University of Wisconsin. So we have this framework to do some network testing without multiple devices and a bunch of wires. Switchyard documentation is available here. And this is the document you read most often. In this lab we will combine Mininet, Wireshark and Swithyard together, as we said before. We expect that you will cost 4 days on this. It is long but important. Git (Optional) You can use Git to manage your projects with a clear editing history and we recommend using it. It is better to have your local repository synchronized with a remote backup on GitHub or some one else. The tutorial of Git is listed below. 廖雪峰的 Git 教程 We expect that you will cost 2 days on this. "},"content/ch00/mininet.html":{"url":"content/ch00/mininet.html","title":"How to use Mininet","keywords":"","body":"How to use Mininet We expect that you have read the Mininet Walkthrough at least. Then here is a minimum walkthrough you should do. Everyday Mininet Usage First, a (perhaps obvious) note on command syntax for this walkthrough: $ preceeds Linux commands that should be typed at the shell prompt mininet> preceeds Mininet commands that should be typed at Mininet’s CLI, # preceeds Linux commands that are typed at a root shell prompt We will show the differences later. Start Mininet So let's start with Mininet startup options. Type the following command to display a help message. Read the output for more usages of Mininet. $ sudo mn -h [!WARNING|style:flat] Commands start with sudo or run as a superuser (prompt like #) are dangerous. Avoid doing things like that. But you need run Mininet as a superuser so be careful. Then let's build a Mininet default topology. $ sudo mn You will see the same output as the picture above. See what Mininet tells us. The default topology contains two hosts and one switch. They link like this h1 --- s1 --- h2 And you now are in Mininet CLI starts with mininet>. The next thing is to interact with Hosts. Keep this open and let's go to the next subsection. Interact with Hosts First let's see what we can do in Mininet CLI. mininet> help Display nodes. mininet > nodes Display links. mininet> net Dump information about all nodes. This command is useful. mininet> dump You should see the switch and two hosts listed. If the first string typed into the Mininet CLI is a host, switch or controller name, the command is executed on that node. Run a command on a host process. mininet> h1 ifconfig -a And you can start a pop-up terminal emulator in one host. mininet> h1 xterm The new window pops up here is the terminal emulator of h1. If you type ifconfig -a here, the output is totally the same as you type h1 ifconfig -a in Mininet CLI. Test Connectivity Between Hosts Now, verify that you can ping from host 0 to host 1. You can also do it in pop-up xterm at h1. mininet> h1 ping -c 1 h2 An easier way to run this test is to use the Mininet CLI built-in pingall command, which does an all-pairs ping. mininet> pingall Run A Simple Web Server and Client Remember that ping isn’t the only command you can run on a host! Mininet hosts can run any command or application that is available to the underlying Linux system (or VM) and its file system. You can also enter any bash command, including job control (&, jobs, kill, etc..) Next, try starting a simple HTTP server on h1, making a request from h2, then shutting down the web server. mininet> h1 python -m SimpleHTTPServer 80 & mininet> h2 wget -O - h1 ... mininet> h1 kill %python Exit the CLI. mininet> exit Cleanup If Mininet crashes for some reason, clean it up. $ sudo mn -c Custom Topologies Custom topologies can be easily defined as well, using a simple Python API. The example here connects 4 devices as a star topology shows below. This file is in the Switchyard repository examples/start_mininet.py. #!/usr/bin/python import sys from mininet.topo import Topo from mininet.net import Mininet from mininet.log import lg from mininet.node import CPULimitedHost from mininet.link import TCLink from mininet.util import irange, custom, quietRun, dumpNetConnections from mininet.cli import CLI from time import sleep, time from subprocess import Popen, PIPE import subprocess import argparse import os parser = argparse.ArgumentParser(description=\"Mininet pyswitch topology\") # no arguments needed as yet :-) args = parser.parse_args() lg.setLogLevel('info') class PySwitchTopo(Topo): def __init__(self, args): # Add default members to class. super(PySwitchTopo, self).__init__() # Host and link configuration # # # server1 # \\ # hub----client # / # server2 # nodeconfig = {'cpu':-1} self.addHost('server1', **nodeconfig) self.addHost('server2', **nodeconfig) self.addHost('hub', **nodeconfig) self.addHost('client', **nodeconfig) for node in ['server1','server2','client']: # all links are 10Mb/s, 100 millisecond prop delay self.addLink(node, 'hub', bw=10, delay='100ms') def set_ip(net, node1, node2, ip): node1 = net.get(node1) ilist = node1.connectionsTo(net.get(node2)) # returns list of tuples intf = ilist[0] intf[0].setIP(ip) def reset_macs(net, node, macbase): ifnum = 1 node_object = net.get(node) for intf in node_object.intfList(): node_object.setMAC(macbase.format(ifnum), intf) ifnum += 1 for intf in node_object.intfList(): print node,intf,node_object.MAC(intf) def set_route(net, fromnode, prefix, nextnode): node_object = net.get(fromnode) ilist = node_object.connectionsTo(net.get(nextnode)) node_object.setDefaultRoute(ilist[0][0]) def setup_addressing(net): reset_macs(net, 'server1', '10:00:00:00:00:{:02x}') reset_macs(net, 'server2', '20:00:00:00:00:{:02x}') reset_macs(net, 'client', '30:00:00:00:00:{:02x}') reset_macs(net, 'hub', '40:00:00:00:00:{:02x}') set_ip(net, 'server1','hub','192.168.100.1/24') set_ip(net, 'server2','hub','192.168.100.2/24') set_ip(net, 'client','hub','192.168.100.3/24') def disable_ipv6(net): for v in net.values(): v.cmdPrint('sysctl -w net.ipv6.conf.all.disable_ipv6=1') v.cmdPrint('sysctl -w net.ipv6.conf.default.disable_ipv6=1') def main(): topo = PySwitchTopo(args) net = Mininet(controller=None, topo=topo, link=TCLink, cleanup=True) setup_addressing(net) disable_ipv6(net) net.interact() if __name__ == '__main__': main() In general, you don't need to modify the topology file we provide. But if you do, you need the document Introduction to Mininet which gives you the Mininet Python API. Please read it carefully. Then let's start this topology. $ sudo python examples/start_mininet.py In this topology, hosts can not ping each other because the device named hub has no routing rules configured, so exit here. In the section of Switchyard, we will make it work. [!NOTE] Mininet topology scripts are written in Python 2. "},"content/ch00/wireshark.html":{"url":"content/ch00/wireshark.html","title":"How to use Wireshark","keywords":"","body":"How to use Wireshark We expect that you have complete How to use Mininet. Then you will learn how to use Wireshark in it. Capturing Packets First start the default Mininet topology. $ sudo mn Then open wireshark in h1. mininet> h1 wireshark & You need to choose which traffic you want to capture. Packets will send and receive on h1-eth0 so you double click it. It will be empty or some ICMPv6 packets be captured. Let's make some traffic ourselves. mininet> h1 ping -c 1 h2 So here we have more packets captured. You may not know why these packets show up, but you will learnd in the next few lessons. Now let's filter some packets by typing protocol name on the filter text box. You can also check the field in the packets like ethernet source MAC address. The value will be highlighted both in packet details and packet raw bytes. "},"content/ch00/switchyard.html":{"url":"content/ch00/switchyard.html","title":"How to program in Switchyard","keywords":"","body":"How to program in Switchyard We expect that you have complete How to use Mininet and How to use Wireshark. Next is the most important section that tells how to program in Switchyard. We will show you a hub, just forward any input packets to any other interfaces. There are three files for this section. examples/start_mininet.py examples/myhub.py examples/hubtests.py The Switchyard documentation also uses these files to show many useful APIs. Again, it is very important to read it. In this section we do not show you the APIs but the workflow and a little code explanation. Prepare Your Test Script You need to construct test script yourself. But we have some template test scripts help you. Here is the test script for our hub. #!/usr/bin/env python3 from switchyard.lib.userlib import * def mk_pkt(hwsrc, hwdst, ipsrc, ipdst, reply=False): ether = Ethernet(src=hwsrc, dst=hwdst, ethertype=EtherType.IP) ippkt = IPv4(src=ipsrc, dst=ipdst, protocol=IPProtocol.ICMP, ttl=32) icmppkt = ICMP() if reply: icmppkt.icmptype = ICMPType.EchoReply else: icmppkt.icmptype = ICMPType.EchoRequest return ether + ippkt + icmppkt def hub_tests(): s = TestScenario(\"hub tests\") s.add_interface('eth0', '10:00:00:00:00:01') s.add_interface('eth1', '10:00:00:00:00:02') s.add_interface('eth2', '10:00:00:00:00:03') # test case 1: a frame with broadcast destination should get sent out # all ports except ingress testpkt = mk_pkt(\"30:00:00:00:00:02\", \"ff:ff:ff:ff:ff:ff\", \"172.16.42.2\", \"255.255.255.255\") s.expect(PacketInputEvent(\"eth1\", testpkt, display=Ethernet), \"An Ethernet frame with a broadcast destination address should arrive on eth1\") s.expect(PacketOutputEvent(\"eth0\", testpkt, \"eth2\", testpkt, display=Ethernet), \"The Ethernet frame with a broadcast destination address should be forwarded out ports eth0 and eth2\") # test case 2: a frame with any unicast address except one assigned to hub # interface should be sent out all ports except ingress reqpkt = mk_pkt(\"20:00:00:00:00:01\", \"30:00:00:00:00:02\", '192.168.1.100','172.16.42.2') s.expect(PacketInputEvent(\"eth0\", reqpkt, display=Ethernet), \"An Ethernet frame from 20:00:00:00:00:01 to 30:00:00:00:00:02 should arrive on eth0\") s.expect(PacketOutputEvent(\"eth1\", reqpkt, \"eth2\", reqpkt, display=Ethernet), \"Ethernet frame destined for 30:00:00:00:00:02 should be flooded out eth1 and eth2\") resppkt = mk_pkt(\"30:00:00:00:00:02\", \"20:00:00:00:00:01\", '172.16.42.2', '192.168.1.100', reply=True) s.expect(PacketInputEvent(\"eth1\", resppkt, display=Ethernet), \"An Ethernet frame from 30:00:00:00:00:02 to 20:00:00:00:00:01 should arrive on eth1\") s.expect(PacketOutputEvent(\"eth0\", resppkt, \"eth2\", resppkt, display=Ethernet), \"Ethernet frame destined to 20:00:00:00:00:01 should be flooded out eth0 and eth2\") # test case 3: a frame with dest address of one of the interfaces should # result in nothing happening reqpkt = mk_pkt(\"20:00:00:00:00:01\", \"10:00:00:00:00:03\", '192.168.1.100','172.16.42.2') s.expect(PacketInputEvent(\"eth2\", reqpkt, display=Ethernet), \"An Ethernet frame should arrive on eth2 with destination address the same as eth2's MAC address\") s.expect(PacketInputTimeoutEvent(1.0), \"The hub should not do anything in response to a frame arriving with a destination address referring to the hub itself.\") return s scenario = hub_tests() The var scenario is very important in the test framework of Switchyard, do not forget it. Then you need to construct your events happend on your hub like packets in and out on which interface. All test APIs used is introduced here. Implement your device Then you need to implement your device. Generally, your initial test files and device logic are not complete. You need to modify them step by step. This programming mode is called Test Driven Development (TDD). Here is our hub code. #!/usr/bin/env python3 ''' Ethernet hub in Switchyard. ''' from switchyard.lib.userlib import * def main(net): my_interfaces = net.interfaces() mymacs = [intf.ethaddr for intf in my_interfaces] while True: try: timestamp,dev,packet = net.recv_packet() except NoPackets: continue except Shutdown: return log_debug (\"In {} received packet {} on {}\".format(net.name, packet, dev)) eth = packet.get_header(Ethernet) if eth is None: log_info(\"Received a non-Ethernet packet?!\") continue if eth.dst in mymacs: log_info (\"Received a packet intended for me\") else: for intf in my_interfaces: if dev != intf.name: log_info (\"Flooding packet {} to {}\".format(packet, intf.name)) net.send_packet(intf, packet) net.shutdown() In Switchyard, the device you want to be the hub will run this script and act like a hub by receiving any packets and forwarding to any other interfaces except the packets towards the hub itself. The APIs used in this file is introduced here. Runing in the Test Environment [!NOTE|style:flat] You need to activate your Python virtual environment first in any case you want to run Switchyard. This step is very important. In the root dictionary of Switchyard, run $ source ./syenv/bin/activate You can test your hub code with your test file in Switchyard test mode. At minimum you would invoke swyard as follows. $ swyard -t examples/hubtests.py examples/myhub.py Note that the -t option puts swyard in test mode. The argument to the -t option should be the name of the test scenario to be executed, and the final argument is the name of your code. After that, you will get some output shows if your tests pass or fail. More about test environment and some debug methods are introduced here. Running in the Mininet First let's start our topology we provided at examples/start_mininet.py. $ sudo python examples/start_mininet.py Then run your hub code to the device you what. Here must be the root of our star shape topology named hub. It is better to open xterm on it so you can see the output of it. mininet> xterm hub Then run your hub code on it. Remember activate your Python virtual environment first. # source ./syenv/bin/activate # swyard examples/myhub.py ... here is your hub logs ... Now you have your topology ready and your hub running, let's see if it works. In Mininet CLI, type pingall and return. mininet> pingall *** Ping: testing ping reachability client -> X server1 server2 hub -> X X X server1 -> client X server2 server2 -> client X server1 *** Results: 50% dropped (6/12 received) This is the output what you will see. You are able to capture in Mininet too. In any host you what to capture packets, run wireshark on it. In our case, we run wireshark on the host named client. Then we ping client to server1. mininet> client wireshark & mininet> client ping -c1 server1 "},"appendix/appendix.html":{"url":"appendix/appendix.html","title":"Appendix","keywords":"","body":"Appendix Some notes and additional materials are in this chapter. "},"appendix/environment-setup.html":{"url":"appendix/environment-setup.html","title":"Environment Setup","keywords":"","body":"Environment Setup If you see here then you must be a high-end player, the instructions here will be very simple. Install Switchyard You can find instructions here, the repository of switchyard on GitHub. A quick note here for Ubuntu. git clone https://github.com/jsommers/switchyard.git sudo apt-get install libffi-dev libpcap-dev python3-dev python3-pip You can install Switchyard and the necessary related packages in an isolated Python virtual environment (\"venv\"), which is the recommended path, or in the system directories, which is often less desirable. The venv route is highly suggested, since it makes all installation \"local\" and can easily destroyed, cleaned up, and recreated. To create a new virtual environment, you could do something like the following under your workspace folder python3 -m venv syenv You can change the name syenv to whatever you'd like to name your virtual environment. Next, you need to activate the environment. The instructions vary depending on the shell you're using. On bash, the command is source ./syenv/bin/activate You'll need to replace syenv with whatever you named the virtual environment. If you're using a different shell than bash, refer to Python documentation on the venv module. Finally, install Switchyard. All the required additional libraries should be automatically installed, too. python3 -m pip install switchyard Then I suggest to exclude your virtual environment out of git tracking. Add this line in .gitignore syenv/ Install Mininet sudo apt-get install mininet Or you want to build mininet yourself. The installation guide is here. Install Wireshark sudo add-apt-repository ppa:wireshark-dev/stable sudo apt-get update sudo apt-get install wireshark You need to configure wireshark during installation. For non-superusers capturing packets, choose Yes here. Then add your user to wireshark user group to allow you capturing packets. sudo usermod -a -G wireshark $USER Other Softwares You also want to install some editors like Vim, Emacs, Visual Studio Code, Sublime and so on. But we do not install any one of them to avoiding a quarrel about the best editor. Chose your favorite one and install it yourself. Another helpful module VBoxGusetAdditions is not installed because various virtual machine hypervisors you will use. "},"appendix/about-this-repository.html":{"url":"appendix/about-this-repository.html","title":"About This Repository","keywords":"","body":"About This Repository This repository is the sorce code of our manual. Building You need to install gitbook-cli first. Then run gitbook build . docs When you build this for the first time, you need to install plugins. gitbook install License The manual is distributed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. Repository Sturcture The body is placed under the content folder, and the chapters are placed in the corresponding chapter folder, starting with ch and followed by two-digit numbers. Each section and subsection is placed in the chapter folder. The pictures and other content used in the text are placed in the assets folder in the corresponding chapter folder. "}}