{"./":{"url":"./","title":"Computer Network Lab Manual","keywords":"","body":"Computer Network Lab Manual Computer Network, Nanjing University, Spring 2020 Course Info Course Number: 22010050 Lecturer: Chen Tian & Wenzhong Li Website: https://cs.nju.edu.cn/lwz/networks-2020/ Contact Course QQ group: 940577165 You can find TAs and our 教学立方 invitation code after joining this group. [!TIP] You may have many questions about our labs. There are some questions can be answered in our manual, some can be answered by searching the Internet, and some we have not mentioned which need to be added to our manual. We welcome the third one because the answers to the first two questions are readily available. To give you faster access to the answers, you need to take a look at this article 提问的智慧. Lab Assignments Lab 1: Switchyard & Mininet Out: 2020-3-4, due 2020-3-18. Start the lab here Lab 2: Learning Switch Out: 2020-3-11, due 2020-3-25. Start the lab here IPv4 Router Lab 3: Respond to ARP Out: 2020-3-25, due 2020-4-8. Lab 4: Forwarding Packets Out: 2020-4-8, due 2020-4-22. Lab 5: Respond to ICMP Out: 2020-4-22, due 2020-5-6. Reliable Communication Lab 6: Sender and Router Out: 2020-5-6, due 2020-5-20. Lab 7: Receiver Out: 2020-5-20, due 2020-6-3. Policies We encourage discussions with others to clarify questions about homework problems and programming assignment problem statements. However [!DANGER|style:flat] Programming solutions must be your own. Do not make your remote assignment repository public. "},"content/ch01/lab-1.html":{"url":"content/ch01/lab-1.html","title":"Lab 1: Switchyard & Mininet","keywords":"","body":"Lab 1: Switchyard & Mininet Overview In this chapter we will introduce all preparations for our network experiments. Then your are going to modify the examples we provide according to our requirements. Details Our lab assignments are based on CS640 in University of Wisconsin. Most materials are the same. In the future, we will improve the experiment based on your feedback. In this lab assignment, you will gradually master our experimental environment. But some preliminary abilities are required in our experiments such as how to program and debug in Linux. If you are not familiar with these, feel free to contact TAs. We will provide you with some helpful information to get started quickly. Platform The platform of our labs is Switchyard. You can implement a device with various functions in Switchyard by writing Python codes. Then you can run your device in Mininet and capture packets using Wireshark. You will use Git to manage your projects and submit them. All these software are installed on Linux. We recommend using Visual Studio Code as your editor. Here is the list of softwares we mentioned (sorted by learning order). Linux Python Git Mininet Wireshark Switchyard VS Code Your Tasks [!NOTE] The sentences marked with ✅ are related to the content of your report. Please pay attention. Task 1: Get Ready Meet the requirements for using Linux, Python and Git. We assume that you have a basic understanding of these contents. Start your task here Task 2: An Example Meet the requirements for using Mininet, Wireshark and Switchyard. At the meantime you will learn how to complete this assignment. Start your task here Task 3: NJU GitLab Meet the requirements for using Mininet, Wireshark and Switchyard. At the meantime you will learn how to complete this assignment. Start your task here [!DANGER] Do not skip this task. We use NJU GitLab to collect your projects. Task 4: Your Modification After Task 1 2 3, you are ready to do some exercises on our platform and count 4. Start your task here Handing it in Report We will provide a template of your lab assignment report here. You need to submit the report in your repository named _lab_1. The format of your report can be Microsoft Doc or PDF. An example is 123456789拾佰仟_lab_1.docx. Capture file The capture file's name should be lab_1.pcap. If you capture packets using superuser, you may meet some problems. Read the tips below. [!WARNING] You may (or as I expect you must) meet the error when you try to modify/delete the files generated by Wireshark or Switchyard programs running on hosts in Mininet. It is because the owner of these files is superuser root. You need to change the owner to your login user. Run the command below on your capture file. Replace to the file path of your capture file. $ sudo chown $USER:$USER Another useful command ls -l can check if the owner of the file is root. You can see the file belonging to root is test.log in the example. (syenv) cyq@cyq-VirtualBox:~/switchyard$ ls -l total 88 -rw-rw-r-- 1 cyq cyq 35147 2月 20 17:33 COPYING -rw-rw-r-- 1 cyq cyq 427 2月 20 17:33 Dockerfile drwxrwxr-x 6 cyq cyq 4096 2月 20 17:33 docs drwxrwxr-x 3 cyq cyq 4096 2月 20 17:33 documentation drwxrwxr-x 4 cyq cyq 4096 2月 21 00:01 examples -rw-rw-r-- 1 cyq cyq 5119 2月 20 17:33 README.rst -rw-rw-r-- 1 cyq cyq 144 2月 20 17:33 requirements.txt -rwxrwxr-x 1 cyq cyq 405 2月 20 17:33 runtests.sh -rw-rw-r-- 1 cyq cyq 2266 2月 20 17:33 setup.py drwxrwxr-x 4 cyq cyq 4096 2月 20 17:33 switchyard drwxrwxr-x 6 cyq cyq 4096 2月 20 17:37 syenv -rw-r--r-- 1 root root 181 2月 21 21:42 lab_1.pcap drwxrwxr-x 2 cyq cyq 4096 2月 20 17:33 tests In this case, running the command sudo chown $USER:$USER ./lab_1.pcap can change the owner to my user cyq. As we mentioned before, be careful when using sudo since it may have potential risks. Submit to NJU GitLab When you are ready to submit, do the following. Modify your code according to Task 3, complete your report and save your capture file. When you have done your work, put your report, code and capture file in the folder lab_1 and commit them. Tag the commit named which you want to submit. An example is 123456789/lab_1. For more about tag, read Git 基础 - 打标签. Finally your project will look like switchyard/ ├─docs/ ├─.../ m ├─lab_1/ + │ ├─123456789拾佰仟_lab_1.docx m │ ├─hubtests.py + │ ├─lab_1.pcap m │ ├─myhub.py m │ └─start_mininet.py ├─.gitignore └─... [!WARNING] The file names in your submission have to exactly match the file names above. Otherwise, you will lose points! Submit your work by pushing your local repository to your remote repository with your tags by running the command git push origin --tags. [!WARNING] Only commit your source code to your local repository. If there are some generated files that are not source code, ignore them by adding them in the file .gitignore. "},"content/ch01/prerequisites.html":{"url":"content/ch01/prerequisites.html","title":"Task 1: Prerequisites","keywords":"","body":"Task 1: Prerequisites There are three things you need to know. The operating system we use is Linux. The program language we use is Python. And the distributed version control system we use is Git. We list some helpful materials below. Linux Python Git In further experiments, we assume that you have mastered the use of these tools. "},"content/ch01/linux.html":{"url":"content/ch01/linux.html","title":"Linux","keywords":"","body":"Linux The operating system of our experimental environment is Ubuntu 18.04 which is a free and open-source Linux distribution. In order to run Linux, you need to install a virtual machine hypervisor on your computer. There are two reasons. Our experiments involve changes to the network. Using a virtual machine (VM) can avoid impact on your computer. We will introduce Mininet and Switchyard later. It is much more easier to install and run them on Linux. [!NOTE] You are also free to use your favorite virtualization software for the lab assignment but you will most probably have to deal with the possible issues on yourself. Install VirtualBox First download the VirtualBox installer, you can find it here. You can choose the latest VirtualBox installer. If the operating system of your host is Windows, then click the download link \"Windows hosts\". Another tool you need to download is \"Extension Pack\" which allows you resize your Linux display in VirtualBox. We highlight them in the picture below. After completing download, install VirtualBox first then the extension pack. Import the VM Image To ensure that your experimental environment is consistent, we provide a VM image. This image has Switchyard, Mininet and Wireshark installed so you do not need to worry about setting up the environment. You can find the VM image here. User name: njucs Password: 123 You can learn about importing a VM image in VirtualBox here. Install the Extension in VM Start your VM and check if your Linux runs well. You will find the display size is fixed to 800×600. To resize it you need to install the VirtualBox extension pack into your VM. You can learn about installing the extension at here. Use Linux Most of our operations will be completed inside the terminal. You need to know Power on & off File system operations File and User permissions Run programs A tutorial of Linux can be found at 鸟哥的 Linux 私房菜 —— 基础学习篇. Select the part you want to know and read it. I Don't Like Your VM If you are a free soul and want to setup Switchyard in a different environment you are welcome to do that as well. You can find some useful information here. This might or might not be useful for you depending on your environment. "},"content/ch01/python.html":{"url":"content/ch01/python.html","title":"Python","keywords":"","body":"Python Switchyard and Mininet are developed in Python. So you need to program in Python (though there are some methods to avoid using Python). Python is an easy-learning language. If you are not familiar with it, here are some materials for you to get started. 廖雪峰的 Python 3 教程 Python 教程 Learn Python - Free Interactive Python Tutorial Our VM is Python preinstalled (both version 2 and 3) so you can skip installing. Topics you need to know about Python are listed here: Python Interpreter Data Types (Important) Data Structures (Important) Flow Control (Important) Functions (Important) Modules Input and Output Errors and Exceptions Standard Library Virtual Environments and Packages (Important) Except those topics marked as important, it is no need to read it carefully, just program as you learn. We expect that you will cost about 3 days on this if you haven't worked with Python. [!NOTE] Python 3 is the main language you will use in Switchyard programming. But you need to know some difference between Python 3 and Python 2 though they are mostly the same. Because you may write some Mininet topology scripts using Python 2. In our VM, you need to type python3 to start Python 3 and python to start Python 2. "},"content/ch01/git.html":{"url":"content/ch01/git.html","title":"Git","keywords":"","body":"Git You can use Git to manage your projects with a clear editing history and we recommend using it. It is better to have your local repository synchronized with a remote backup on GitHub or some one else. The tutorial of Git is listed below. 廖雪峰的 Git 教程 We expect that you will cost 2 days on this. Then please sign up on NJU GitLab. You will submit your codes on it. "},"content/ch01/workflow.html":{"url":"content/ch01/workflow.html","title":"Task 2: Workflow","keywords":"","body":"Task 2: Workflow Our experiment requires Mininet to build a network. You will use Switchyard to run your network device. Wireshark is used to capture packets. And you may use Visual Studio Code to develope your projects. Here are four sections to introduce them and we ask you to read these sections carefully. This will affect your later experiments. You will see an example of the network hub, a network hardware device for connecting multiple Ethernet devices together and making them act as a single network segment. It has multiple input/output (I/O) ports, in which a signal introduced at the input of any port appears at the output of every port except the original incoming. A hub works at the physical layer (layer 1) of the OSI model. In short, hub allows devices to communicate with each other. Here you don't need to understand the working principle of hub. VS Code Mininet Wireshark Switchyard "},"content/ch01/vscode.html":{"url":"content/ch01/vscode.html","title":"VS Code","keywords":"","body":"VS Code You can use Visual Studio Code (VSC) to develope your projects. I will show how to install it and introduce some plugins may help you. This tutorial is prepared for those who want to take full control of Switchyard in one editor. We use Ubuntu 18.04 here. As we have provided the VM image with VSC preinstalled, you can skip the installation. We expect that you will spend several hours on this. Install VSC You can choose the VM image with VSC preinstalled. But someone like to install it themselves. The easiest way to install Visual Studio Code for Debian/Ubuntu based distributions is to download and install the .deb package (64-bit), either through the graphical software center if it's available, or through the command line with: $ sudo apt install ./.deb Develope Switchyard with VSC [!TIP] Here we will get in touch with Switchyard in advance. You can just skim the content of Switchyard now. After reading the section Switchyard, come back again. Open the folder of Switchyard in VSC. You can open files in the explorer and edit them. Then there are some plugins you may want to install. For Python, check this extension and install it. Next open any Python files and you will see a pop-up message ask you whether you want to install a linter. Pylint is enough to use so install it. You have got almost every thing you need here. But you may what to format your document by right click on your editor and choose \"Format Document\". VSC will tell you that you need to install a formatter. Yapf is better for me but you are free to use others. Debug Switchyard with VSC Switchyard document about debug shows that you are free to choose other debuggers. Let's replace pbd with VSC debugger. This will works when running in Switchyard test environment. For VSC, you need to create debugging configuration. The example next shows how to debug examples/myhub.py with examples/hubtests.py. Set break point in your code and click the configuration to debug. Run Switchyard This part is not VSC integrated, you need to run Switchyard in the terminal. Read the section Switchyard for more. "},"content/ch01/mininet.html":{"url":"content/ch01/mininet.html","title":"Mininet","keywords":"","body":"Mininet Mininet enables you to quickly create, interact with, customize and share a software defined network prototype, and provides a smooth path to running on hardware. The most useful material is their website. Here is the Mininet Walkthrough. At this stage you will encounter some concepts you are not familiar with such as switches and hosts, but remember to come back after you have learned them. In this section, we will have a small practice of Mininet. [!NOTE] Ignore the content about switches like Open vSwitch (OVS) setting up. We expect that you will spend 2 days on this. Install Mininet If you find that Mininet is not installed on your system, run this command to install it. $ sudo apt-get install mininet Or you want to build mininet yourself. The installation guide is here. Install Xterm If you find that Xterm is not installed on your system, run this command to install it. $ sudo apt-get install xterm Everyday Mininet Usage First, a (perhaps obvious) note on command syntax for this walkthrough: $ proceeds Linux commands that should be typed at the shell prompt mininet> proceeds Mininet commands that should be typed at Mininet’s CLI, # proceeds Linux commands that are typed at a root shell prompt Start Mininet So let's start with Mininet startup options. Type the following command to display a help message. Read the output for more usages of Mininet. $ sudo mn -h [!WARNING|style:flat] Commands start with sudo or run as a superuser (prompt like #) are dangerous. Avoid doing things like that. But you need run Mininet as a superuser so be careful. Then let's build a Mininet default topology. $ sudo mn You will see the same output as the picture above. See what Mininet tells us. The default topology contains two hosts and one switch. They link like this h1 --- s1 --- h2 And you now are in Mininet CLI starts with mininet>. The next thing is to interact with Hosts. Keep this open and let's go to the next subsection. Interact with Hosts First let's see what we can do in Mininet CLI. mininet> help Display nodes. mininet > nodes Display links. mininet> net Dump information about all nodes. This command is useful. mininet> dump You should see the switch and two hosts listed. If the first string typed into the Mininet CLI is a host, switch or controller name, the command is executed on that node. Run a command on a host process. mininet> h1 ifconfig -a And you can start a pop-up terminal emulator in one host. mininet> h1 xterm The new window pops up here is the terminal emulator of h1. If you type ifconfig -a here, the output is totally the same as you type h1 ifconfig -a in Mininet CLI. Test Connectivity Between Hosts Now, verify that you can ping from host 0 to host 1. You can also do it in pop-up xterm at h1. You will learn what ping is in the later lessons. Now ping just tells you whether two hosts is well-connected. mininet> h1 ping -c 1 h2 An easier way to run this test is to use the Mininet CLI built-in pingall command, which does an all-pairs ping. mininet> pingall Run A Simple Web Server and Client Remember that ping isn’t the only command you can run on a host! Mininet hosts can run any command or application that is available to the underlying Linux system (or VM) and its file system. You can also enter any bash command, including job control (&, jobs, kill, etc..) Next, try starting a simple HTTP server on h1, making a request from h2, then shutting down the web server. mininet> h1 python -m SimpleHTTPServer 80 & mininet> h2 wget -O - h1 ... mininet> h1 kill %python Exit the CLI. mininet> exit Cleanup If Mininet crashes for some reason, clean it up. $ sudo mn -c Custom Topologies Custom topologies can be easily defined as well, using a simple Python API. The example here connects 4 devices as a star topology shows below. This file is in the Switchyard repository examples/start_mininet.py. #!/usr/bin/python import sys from mininet.topo import Topo from mininet.net import Mininet from mininet.log import lg from mininet.node import CPULimitedHost from mininet.link import TCLink from mininet.util import irange, custom, quietRun, dumpNetConnections from mininet.cli import CLI from time import sleep, time from subprocess import Popen, PIPE import subprocess import argparse import os parser = argparse.ArgumentParser(description=\"Mininet pyswitch topology\") # no arguments needed as yet :-) args = parser.parse_args() lg.setLogLevel('info') class PySwitchTopo(Topo): def __init__(self, args): # Add default members to class. super(PySwitchTopo, self).__init__() # Host and link configuration # # # server1 # \\ # hub----client # / # server2 # nodeconfig = {'cpu':-1} self.addHost('server1', **nodeconfig) self.addHost('server2', **nodeconfig) self.addHost('hub', **nodeconfig) self.addHost('client', **nodeconfig) for node in ['server1','server2','client']: # all links are 10Mb/s, 100 millisecond prop delay self.addLink(node, 'hub', bw=10, delay='100ms') def set_ip(net, node1, node2, ip): node1 = net.get(node1) ilist = node1.connectionsTo(net.get(node2)) # returns list of tuples intf = ilist[0] intf[0].setIP(ip) def reset_macs(net, node, macbase): ifnum = 1 node_object = net.get(node) for intf in node_object.intfList(): node_object.setMAC(macbase.format(ifnum), intf) ifnum += 1 for intf in node_object.intfList(): print node,intf,node_object.MAC(intf) def set_route(net, fromnode, prefix, nextnode): node_object = net.get(fromnode) ilist = node_object.connectionsTo(net.get(nextnode)) node_object.setDefaultRoute(ilist[0][0]) def setup_addressing(net): reset_macs(net, 'server1', '10:00:00:00:00:{:02x}') reset_macs(net, 'server2', '20:00:00:00:00:{:02x}') reset_macs(net, 'client', '30:00:00:00:00:{:02x}') reset_macs(net, 'hub', '40:00:00:00:00:{:02x}') set_ip(net, 'server1','hub','192.168.100.1/24') set_ip(net, 'server2','hub','192.168.100.2/24') set_ip(net, 'client','hub','192.168.100.3/24') def disable_ipv6(net): for v in net.values(): v.cmdPrint('sysctl -w net.ipv6.conf.all.disable_ipv6=1') v.cmdPrint('sysctl -w net.ipv6.conf.default.disable_ipv6=1') def main(): topo = PySwitchTopo(args) net = Mininet(controller=None, topo=topo, link=TCLink, cleanup=True) setup_addressing(net) disable_ipv6(net) net.interact() if __name__ == '__main__': main() We build a topology inside the constructor function __init__ of class PySwitchTopo. If you want to change the topology, you should modify it. We setup interfaces in the function setup_addressing, you will learn what happens here after knowing Ethernet and IP protocol. In general, you don't need to modify the topology file we provide. But if you do, you need the document Introduction to Mininet which gives you the Mininet Python API. Please read it carefully. Then let's start this topology. $ sudo python examples/start_mininet.py In this topology, hosts can not ping each other because the device named hub has no routing rules configured, so exit here. In the section of Switchyard, we will make it work. [!NOTE] Mininet topology scripts are written in Python 2. "},"content/ch01/wireshark.html":{"url":"content/ch01/wireshark.html","title":"Wireshark","keywords":"","body":"How to use Wireshark Wireshark is the world’s foremost and widely-used network protocol analyzer. It lets you see what’s happening on your network at a microscopic level and is the de facto (and often de jure) standard across many commercial and non-profit enterprises, government agencies, and educational institutions. You will use it to inspect your network setting up by Mininet, and test the function of your device written in Switchyard. We also have a small practice of Wireshark in our manual. Wireshark User’s Guide is a verbose document about Wireshark but We do not recommend it. So sometimes the official document is hard for user to get started. You can find many blogs writing about how to use Wireshark. Read them instead or the first search result in Google here. We expect that this will cost you an afternoon. Install Wireshark If you find that Wireshark is not installed on your system, run these commands to install it. $ sudo add-apt-repository ppa:wireshark-dev/stable $ sudo apt-get update $ sudo apt-get install wireshark You need to configure wireshark during installation. For non-superusers capturing packets, choose Yes here. Then add your user to wireshark user group to allow you capturing packets. $ sudo usermod -a -G wireshark $USER Capturing Packets First start the default Mininet topology. $ sudo mn Then open wireshark in h1. mininet> h1 wireshark & You need to choose which traffic you want to capture. Packets will send and receive on h1-eth0 so you double click it. It will be empty or some ICMPv6 packets be captured. Let's make some traffic ourselves. mininet> h1 ping -c 1 h2 So here we have more packets captured. You may not know why these packets show up, but you will learned in the next few lessons. Now let's filter some packets by typing protocol name on the filter text box. You can also check the field in the packets like ethernet source MAC address. The value will be highlighted both in packet details and packet raw bytes. "},"content/ch01/switchyard.html":{"url":"content/ch01/switchyard.html","title":"Switchyard","keywords":"","body":"How to program in Switchyard Switchyard is a framework for creating, testing, and experimenting with software implementations of networked systems such as Ethernet switches, IP routers, firewalls and middleboxes, and end-host protocol stacks. It is the framework targeting on teaching and used in University of Wisconsin. So we have this framework to do some network testing without multiple devices and a bunch of wires. Switchyard documentation is available here. And this is the document you read most often. In this section we will combine Mininet, Wireshark and Switchyard together. We expect that you have complete How to use Mininet and How to use Wireshark. Next is to learn how to program in Switchyard. We will show you a hub, just forward any input packets to any other interfaces. There are three files for this section. examples/start_mininet.py examples/myhub.py examples/hubtests.py The Switchyard documentation also uses these files to show many useful APIs. Again, this document is very important. You need to read it whenever you get confused with the APIs or Switchyard itself. In this section we do not show you the APIs but the workflow and a little code explanation. We expect that it will take you up to 4 days on this. It may be a little bit tricky. But this is important. Install Switchyard You can find instructions here, the repository of Switchyard on Gitee. A quick note here for Ubuntu. If you can't find the folder switchyard in your home dictionary, you need to get the source code of Switchyard. $ git clone https://gitee.com/shellqiqi/switchyard.git Then you need to get some dependent softwares and libraries. $ sudo apt-get install libffi-dev libpcap-dev python3-dev python3-pip You can install Switchyard and the necessary related packages in an isolated Python virtual environment (\"venv\"), which is the recommended path, or in the system directories, which is often less desirable. The venv route is highly suggested, since it makes all installation \"local\" and can easily destroyed, cleaned up, and recreated. To create a new virtual environment, you could do something like the following under your workspace folder switchyard. $ python3 -m venv syenv [!WARNING] Many students create their virtual environment under ~ so there is a folder ~/syenv, which is WRONG. The right path is ~/switchyard/syenv. After this command, you will find a folder syenv in switchyard, which is the folder of the Python virtual environment. You can change the name syenv to whatever you'd like to name your virtual environment. Next, you need to activate the environment. The instructions vary depending on the shell you're using. On bash, the command is $ source ./syenv/bin/activate Exactly, activate is a runnable file in the folder syenv. You'll need to replace syenv with whatever you named the virtual environment. If you're using a different shell than bash, refer to Python documentation on the venv module. Finally, install Switchyard. All the required additional libraries should be automatically installed, too. $ python3 -m pip install switchyard Then I suggest to exclude your virtual environment out of git tracking. Add this line in .gitignore if there is not. syenv/ Prepare Your Test Script Writing tests to determine whether a piece of code behaves as expected is an important part of the software development process. With Switchyard, it is possible to create a set of tests that verify whether a program attempts to receive packets when it should and sends the right packet(s) out the right ports. A test scenario is Switchyard’s term for a series of tests that verify a program’s behavior. A test scenario is simply a Python source code file that includes a particular variable name (symbol) called scenario, which must refer to an instance of the class TestScenario. A TestScenario object contains the basic configuration for an imaginary network device along with an ordered series of test expectations. These expectations may be one of three types: that a particular packet should arrive on a particular interface/port, that a particular packet should be emitted out one or more ports, and that the user program should time out when calling recv_packet because no packets are available. To start off, here is an example of an empty test scenario: from switchyard.lib.userlib import * scenario = TestScenario(\"test example\") For more about writing tests, you need to read Test Scenario Creation. In later lab assignments, you need to construct test script yourself. But this time we have a template test script helps you. Here is the test script for our hub. #!/usr/bin/env python3 from switchyard.lib.userlib import * def mk_pkt(hwsrc, hwdst, ipsrc, ipdst, reply=False): ether = Ethernet(src=hwsrc, dst=hwdst, ethertype=EtherType.IP) ippkt = IPv4(src=ipsrc, dst=ipdst, protocol=IPProtocol.ICMP, ttl=32) icmppkt = ICMP() if reply: icmppkt.icmptype = ICMPType.EchoReply else: icmppkt.icmptype = ICMPType.EchoRequest return ether + ippkt + icmppkt def hub_tests(): s = TestScenario(\"hub tests\") s.add_interface('eth0', '10:00:00:00:00:01') s.add_interface('eth1', '10:00:00:00:00:02') s.add_interface('eth2', '10:00:00:00:00:03') # test case 1: a frame with broadcast destination should get sent out # all ports except ingress testpkt = mk_pkt(\"30:00:00:00:00:02\", \"ff:ff:ff:ff:ff:ff\", \"172.16.42.2\", \"255.255.255.255\") s.expect(PacketInputEvent(\"eth1\", testpkt, display=Ethernet), \"An Ethernet frame with a broadcast destination address should arrive on eth1\") s.expect(PacketOutputEvent(\"eth0\", testpkt, \"eth2\", testpkt, display=Ethernet), \"The Ethernet frame with a broadcast destination address should be forwarded out ports eth0 and eth2\") # test case 2: a frame with any unicast address except one assigned to hub # interface should be sent out all ports except ingress reqpkt = mk_pkt(\"20:00:00:00:00:01\", \"30:00:00:00:00:02\", '192.168.1.100','172.16.42.2') s.expect(PacketInputEvent(\"eth0\", reqpkt, display=Ethernet), \"An Ethernet frame from 20:00:00:00:00:01 to 30:00:00:00:00:02 should arrive on eth0\") s.expect(PacketOutputEvent(\"eth1\", reqpkt, \"eth2\", reqpkt, display=Ethernet), \"Ethernet frame destined for 30:00:00:00:00:02 should be flooded out eth1 and eth2\") resppkt = mk_pkt(\"30:00:00:00:00:02\", \"20:00:00:00:00:01\", '172.16.42.2', '192.168.1.100', reply=True) s.expect(PacketInputEvent(\"eth1\", resppkt, display=Ethernet), \"An Ethernet frame from 30:00:00:00:00:02 to 20:00:00:00:00:01 should arrive on eth1\") s.expect(PacketOutputEvent(\"eth0\", resppkt, \"eth2\", resppkt, display=Ethernet), \"Ethernet frame destined to 20:00:00:00:00:01 should be flooded out eth0 and eth2\") # test case 3: a frame with dest address of one of the interfaces should # result in nothing happening reqpkt = mk_pkt(\"20:00:00:00:00:01\", \"10:00:00:00:00:03\", '192.168.1.100','172.16.42.2') s.expect(PacketInputEvent(\"eth2\", reqpkt, display=Ethernet), \"An Ethernet frame should arrive on eth2 with destination address the same as eth2's MAC address\") s.expect(PacketInputTimeoutEvent(1.0), \"The hub should not do anything in response to a frame arriving with a destination address referring to the hub itself.\") return s scenario = hub_tests() The function mk_pkt is used to make a packet. For now you don't need to know what the parameters means. The function hub_tests returns a TestScenario object which assigned to scenario. The var scenario is very important in the test framework of Switchyard, do not forget it. We construct the scenario with a name \"hub tests\". Then we add three interfaces with name and MAC address on our hub. In every case, we make a packet then feed it into one interface of our hub with PacketInputEvent. Then we compare the outgoing packets from interfaces of our hub with our expectation packets using PacketOutputEvent. If there is no packet out, we use the function PacketInputTimeoutEvent to check there is no traffic for a period of time. All test APIs used is introduced here. You may want to run this test, we will cover this later. Implement your device Switchyard is the framework enables you to implement a device. A Switchyard program is simply a Python program that includes a particular entry point function which accepts a single parameter. The startup function can simply be named main, but can also be named switchy_main if you like. The function must accept at least one parameter, which is a reference to the Switchyard network object (described below). Method calls on the network object are used to send and receive packets to and from network ports. A Switchyard program isn’t executed directly with the Python interpreter. Instead, the program swyard is used to start up the Switchyard framework and to load your code. When Switchyard starts your code it looks for a function named main and invokes it, passing in the network object as the first parameter. Details on how to start Switchyard (and thus your program) are given in the chapters on running a Switchyard in the test environment and running Switchyard in a live environment. Note that it is possible to pass arguments into a Switchyard program; see Passing arguments into a Switchyard program for details. A Switchyard program will typically also import other Switchyard modules such as modules for parsing and constructing packets, dealing with network addresses, and other functions. These modules are introduced below and described in detail in the API reference chapter. In the later lab assignments, you need to implement your device. Generally, your initial test files and device logic are not complete. You need to modify them step by step. This programming mode is called Test Driven Development (TDD). Here is our hub code. #!/usr/bin/env python3 ''' Ethernet hub in Switchyard. ''' from switchyard.lib.userlib import * def main(net): my_interfaces = net.interfaces() mymacs = [intf.ethaddr for intf in my_interfaces] while True: try: timestamp,dev,packet = net.recv_packet() except NoPackets: continue except Shutdown: return log_debug (\"In {} received packet {} on {}\".format(net.name, packet, dev)) eth = packet.get_header(Ethernet) if eth is None: log_info(\"Received a non-Ethernet packet?!\") continue if eth.dst in mymacs: log_info (\"Received a packet intended for me\") else: for intf in my_interfaces: if dev != intf.name: log_info (\"Flooding packet {} to {}\".format(packet, intf.name)) net.send_packet(intf, packet) net.shutdown() In Switchyard, the device you want to be the hub will run this script and act like a hub by receiving any packets and forwarding to any other interfaces except the packets towards the hub itself. The APIs used in this file is introduced here. Running in the Test Environment [!NOTE|style:flat] You need to activate your Python virtual environment first in any case you want to run Switchyard. This step is very important. In the root dictionary of Switchyard, run $ source ./syenv/bin/activate You can test your hub code with your test file in Switchyard test mode. At minimum you would invoke swyard as follows. $ swyard -t examples/hubtests.py examples/myhub.py Note that the -t option puts swyard in test mode. The argument to the -t option should be the name of the test scenario to be executed, and the final argument is the name of your code. After that, you will get some output shows if your tests pass or fail. More about test environment and some debug methods are introduced here. Running in the Mininet In the test environment, here is no true traffic here. The device only take the packets we provided. We need to challenge the true networking. Here we have Mininet can construct a network. First let's start our topology we provided at examples/start_mininet.py. $ sudo python examples/start_mininet.py Then run your hub code to the device you what. Here must be the root of our star shape topology named hub. It is better to open xterm on it so you can see the output of it. mininet> xterm hub Then run your hub code on it. Remember activate your Python virtual environment first. Replace to the path of Switchyard. # source /syenv/bin/activate # swyard examples/myhub.py ... here is your hub logs ... Now you have your topology ready and your hub running, let's see if it works. In Mininet CLI, type pingall and return. mininet> pingall *** Ping: testing ping reachability client -> X server1 server2 hub -> X X X server1 -> client X server2 server2 -> client X server1 *** Results: 50% dropped (6/12 received) This is the output what you will see. You are able to capture in Mininet too. In any host you want to capture packets, run wireshark on it. In our case, we run wireshark on the host named client. Then we ping client to server1. mininet> client wireshark & mininet> client ping -c1 server1 "},"content/ch01/nju-gitlab.html":{"url":"content/ch01/nju-gitlab.html","title":"Task 3: NJU GitLab","keywords":"","body":"Task 3: NJU GitLab To submit your work, you need to do the following things at the first time: Sign up on https://git.nju.edu.cn with your own NJU email account. Sign in. Import the repository https://git.nju.edu.cn/njucn-2020-spring/switchyard to your own account and make it private, then you will get your own repository url. Here is a brief guide in one picture about how to import the project. Don't fork because that makes your repository public. Share your repository with us. Find \"Members\" in \"Settings\" of your repository. In \"Invite group\", select njucn-2020-spring/student/ and make us as \"Reporter\" or \"Developer\". [!NOTE|style:flat] Please fill out the form in the QQ group file GitLab 私有仓库地址提交 first. After we collect them, we will inform you of the invitation. There is a directory ~/switchyard in your virtual machine (if you use the VM image we provide). Set the remote repository of switchyard to your repository url by running the command git remote set-url origin . Otherwise, clone your own remote repository. "},"content/ch01/modification.html":{"url":"content/ch01/modification.html","title":"Task 4: Modification","keywords":"","body":"Task 3: Modification Preparation Let's start with our example files. Create a directory named lab_1 in ~/switchyard. Your should start by copying the template files examples/start_mininet.py, examples/myhub.py and examples/hubtests.py into lab_1. And your project will look like switchyard/ ├─docs/ ├─.../ + ├─lab_1/ + │ ├─hubtests.py + │ ├─myhub.py + │ └─start_mininet.py ├─.gitignore └─... Play the Tutorial Again You have done the tutorial. However it is necessary to work by yourself. So modify our examples files. [!TIP] We suggest that you can commit in Git when you complete one step. [!WARNING] All of your modifications should be done on the files under your directory lab_1. We will check and compare the git commits to judge the originality of your work. So remember to commit every time you complete one small task. Step 1: Modify the Mininet topology In the section Mininet, we introduced how to construct a topology. So here we have two options for you, choose one to implement. ✅ Then show the details of how you build the topology in your report. Delete server2 in the topology, Or create a different topology containing 6 nodes using hosts and hubs (don't use other kinds of devices). The file you need to modify is lab_1/start_mininet.py. Step 2: Modify the logic of a device In the section Switchyard, we introduced how to program a device. Your task is to count how many packets pass through a hub in and out. You need to log the statistical result every time you receive one packet with the format of each line in: out:. For example, if there is a packet that is not addressed to the hub itself, then the hub may log in:1 out:2. ✅ Then show the log of your hub when running it in Mininet and how you implement it in your report. [!NOTE] In the old version we need you to print the timestamp then we remove it. So many students ask why because there is a function log_info which prints the time of log output. However we want you to log the packet arrival time which is different from output time. Because our explanation is late, if you have implemented it in another way, you do not need to change. The file you need to modify is lab_1/myhub.py. Step 3: Modify the test scenario of a device In the section Switchyard, we introduced how to write the test case. So here we have two options for you, choose one to implement. ✅ Then show the details of your test cases in your report. Create one test case by using the given function mk_pkt with different arguments, Or create one test case with your handmade packet. The file you need to modify is lab_1/hubtests.py. Step 4: Run your device in Mininet In the section Switchyard, we introduced how to run Switchyard programs in Mininet. So run your new hub in your new topology and make sure it works. ✅ Show the procedure in your report. Step 5: Capture using Wireshark Both in section Wireshark and Switchyard, we introduced how to capture packets. In your own topology, capture packets on one host (no hub) while creating some traffic. Save your capture file and submit it with your report and code. ✅ Also you need to describe the details of your capture file. "},"content/ch02/lab-2.html":{"url":"content/ch02/lab-2.html","title":"Lab 2: Learning Switch","keywords":"","body":"Lab 2: Learning Switch Overview In this assignment, you are going to implement the core functionalities of an Ethernet learning switch using the Switchyard framework. An Ethernet switch is a layer 2 device that uses packet switching to receive, process and forward frames to other devices (end hosts, other switches) in the network. A switch has a set of interfaces (ports) through which it sends/receives Ethernet frames. When Ethernet frames arrive on any port, the switch process the header of the frame to obtain information about the destination host. If the switch knows that the host is reachable through one of its ports, it sends out the frame from the appropriate output port. If it does not know where the host is, it floods the frame out of all ports except the input port. Details Your task is to implement the logic of a switch. As it is described in the last paragraph of the \"Ethernet Learning Switch Operation\" section, your switch will also handle the frames that are intended for itself and the frames whose Ethernet destination address is the broadcast address FF:FF:FF:FF:FF:FF. In addition to these, you will also implement three different mechanisms to purge the outdated/stale entries from the forwarding table. This will allow your learning switch to adapt to changes in the network topology. These mechanisms are: Remove an entry from the forwarding table after 10 seconds have elapsed. Remove the least recently used (LRU) entry from the forwarding table. For this functionality assume that your table can only hold 2 entries at a time. If a new entry comes and your table is full, you will remove the entry that has not been matched with a Ethernet frame destination address for the longest time. Remove the entry that has the least traffic volume. For this functionality assume that your table can only hold 2 entries at a time. Traffic volume for an entry is the number of frames that the switch received where Destination MAC address == MAC address of entry. You will implement these mechanisms in three separate Python files. The core functionalities that are explained above will be the same for these implementations. [!WARNING] Please carefully read the FAQ section, for more specific details regarding the implementations Your Tasks In these tasks, you will write the code to implement the core logic in an Ethernet learning switch using the Switchyard framework. Besides using Switchyard for developing and testing your switch, you can deploy it in Mininet to test it in a \"live\" setting. The code you'll need to add for the simplest version of this exercise should be less than 20 lines (and possibly quite a bit less depending on exactly how you write the code). There are extensions to the basic learning switch that could add quite a bit more code. [!NOTE] The sentences marked with ✅ are related to the content of your report. Please pay attention. Task 1: Preparation Initiate your project with our template. Start the task here Task 2: Basic Learning Switch Start with the basic learning switch. Start the task here Task 3: Timeouts Implement timeouts based on the previous task. Start the task here Task 4: LRU Rule Replacement Algorithm Implement LRU rule replacement algorithm based on Task 2. Start the task here Task 5: Least Traffic Volume Rule Replacement Algorithm Implement least traffic volume rule replacement algorithm based on Task 2. Start the task here Handing it in Report We will provide a template of your lab assignment report here. You need to submit the report in your repository named _lab_2. The format of your report can be Microsoft Doc or PDF. An example is 123456789拾佰仟_lab_2.docx. Submit to NJU GitLab To submit your work, you need to do the following things. Modify your code and complete your report. When you have done your work, put your report and code in the folder lab_2 then commit them. Tag the commit named which you want to submit. An example is 123456789/lab_2. Finally your project will look like switchyard/ ├─docs/ ├─.../ m ├─lab_2/ + │ ├─123456789拾佰仟_lab_2.docx m │ ├─myswitch.py m │ ├─myswitch_to.py m │ ├─myswitch_lru.py m │ ├─myswitch_traffic.py │ ├─... m │ └─start_mininet.py ├─.gitignore └─... [!WARNING] The file names in your submission have to exactly match the file names above. Otherwise, you will lose points! Submit your work by pushing your local repository to your remote repository with your tags by running the command git push origin --tags. [!WARNING] Only commit your source code to your local repository. If there are some generated files that are not source code, ignore them by adding them in the file .gitignore. "},"content/ch02/preparation.html":{"url":"content/ch02/preparation.html","title":"Task 1: Preparation","keywords":"","body":"Task 1: Preparation There is an example of a switch without learning implemented in switchyard/examples/exercises/learning_switch/myswitch.py. Let's start with it. Create a directory named lab_2 in switchyard. Copy examples/exercises/learning_switch/switchtopo.py to lab_2/start_mininet.py. Make 4 copies of examples/exercises/learning_switch/myswitch.py to: lab_2/myswitch.py: Your basic learning switch. lab_2/myswitch_to.py: Your learning switch with timeout based entry removal. lab_2/myswitch_lru.py: Your learning switch with LRU based entry removal. lab_2/myswitch_traffic.py: Your learning switch with traffic volume based entry removal. (Optional) Create your test files in lab_2. lab_2/mytests.py: Your test file of lab_2/myswitch.py. lab_2/mytests_to.py: Your test file of lab_2/myswitch_to.py. lab_2/mytests_lru.py: Your test file of lab_2/myswitch_lru.py. lab_2/mytests_traffic.py: Your test file of lab_2/myswitch_traffic.py. Though we will provide the test files, they are incomprehensible. So you should still write test scenarios that test all aspects of your code. You can find our test files below. Download it and you will use it to test your switch later. You can unzip the test files we provide into the folder lab_2. Download compiled test cases here. Finally, your project will look like switchyard ├─docs/ ├─.../ + ├─lab_2/ + │ ├─myswitch.py + │ ├─myswitch_to.py + │ ├─myswitch_lru.py + │ ├─myswitch_traffic.py │ ├─... + │ └─start_mininet.py ├─.gitignore └─... [!WARNING] All of your modifications should be done on the files under your directory lab_2. We will check and compare the git commits to judge the originality of your work. So remember to commit every time you complete one small task. "},"content/ch02/basic-switch.html":{"url":"content/ch02/basic-switch.html","title":"Task 2: Basic Switch","keywords":"","body":"Task 2: Basic Switch Ethernet Learning Switch Operation An Ethernet learning switch is a device that has a set of interfaces (\"ports\") with links connected to other switches, and to end hosts. When Ethernet frames arrive on any port/interface, the switch sends the frame on an appropriate output port if the switch knows that the host is reachable through that port, or floods the frame out all ports if it does not know where the host is. Consider the picture below. Say that Switch 1 doesn't know the locations of any host on the network, and that H1 wants to send an Ethernet frame to H3. When that frame arrives at Switch 1, it sees Ethernet source address 00:00:00:00:00:01 and destination address 00:00:00:00:00:03. From this packet arrival, it knows that it can now reach H1 by send a frame out the same interface on which this frame has arrived. However, it does not know where to send to frame to reach H3, so it floods the packet out all ports except the one on which the frame arrived. Eventually, H3 will receive the frame. If it replies to H1, Switch 1 will receive a frame with the source address as H3's address, and the frame will arrive on the interface connected to Switch 2. At this point, Switch 1 now knows exactly which ports it needs to use to send frames to either H1 or H3. The following flowchart summarizes the example described above. The only additional considerations shown in the flowchart are if the destination address is the same as one of the Ethernet addresses on the switch itself (i.e., the frame is intended for the switch), or the Ethernet destination address is the broadcast address FF:FF:FF:FF:FF:FF. Your switch may have a table like: MAC Address Interface ab:cd:ef:fe:cd:ba interface-0 ... ... Coding Your task is to implement the logic in the above flowchart, using the Switchyard framework. The starter file is named lab_2/myswitch.py, which is the only file you'll need to modify. Some links to Switchyard API documentation which you may find helpful are: Packet Parsing/Construction Introduction Packet Parsing/Construction Reference Ethernet Packet Header Reference Note that the documentation of Switchyard has examples on running Switchyard in test mode and in real mode, along with a walkthrough of creating a simple hub device, which is useful background material for this exercise. Testing You can test your basic learning switch yourself. No test results need to show in your report. Deploying To run your switch in Mininet, run the lab_2/start_mininet.py custom topology script. It will create a small network consisting of a single switch with three hosts (client, server1, and server2) in the following configuration. To start up Mininet using this script, just type: $ sudo python lab_2/start_mininet.py Once Mininet starts up, you should open a terminal window on the Mininet node named \"switch\": mininet> xterm switch In the window that opens (xterm on the node \"switch\"), activate venv and run your switch in \"real\" (non-test) mode: (syenv) # swyard myswitch.py [!NOTE] Note that to run swyard in Mininet in a root shell (such as the shell that is open in response to the xterm command), you will need to activate the Python virtual environment which has Switchyard installed in it. Refer to the Switchyard documentation for more information. To examine whether your switch is behaving correctly, you can do the following: Open terminals on client, server1 and server2 (xterm client, xterm server1 and xterm server2 from the Mininet prompt) In the server1 and server2 terminal, run wireshark. Wireshark is a program that allows you to \"snoop\" on network traffic arriving on a network interface. We'll use this to verify that we see packets arriving at server1 and server2 from client. In the terminal on the client node, type ping -c 2 192.168.100.1. This command will send two \"echo\" requests to the server1 node. The server1 node should respond to each of them if your switch is working correctly. You should see at the two echo request and echo replies in Wireshark running on server1, and you will probably see a couple other packets (e.g., ARP, or Address Resolution Protocol, packets). If you run Wireshark on server2, you should not see the echo request and reply packets (but you will see the ARP packets, since they are sent with broadcast destination addresses). ✅ Analyze and state the results of the above process in your report with screenshots. Do not explain how you do step by step but focus on the switch's forwarding logic. "},"content/ch02/timeouts.html":{"url":"content/ch02/timeouts.html","title":"Task 3: Timeouts","keywords":"","body":"Task 3: Timeouts Timeout Mechanism Real learning switches remove forwarding table entries after some number of seconds have elapsed so that a learning switch can adapt to changes in network topology. Implement a timeout feature in your learning switch. Choose some reasonable value for a timeout (e.g., 10 seconds). The following flowchart summarizes the algorithm described above. Your switch may have a table like: MAC Address Interface Timestamp ab:cd:ef:fe:cd:ba interface-0 123456.123456 ... ... ... Coding Your task is to implement the logic in the above flowchart, using the Switchyard framework. You can start with copying the content of lab_2/myswitch.py to lab_2/myswitch_to.py, which is the only file you'll need to modify. Testing You should first develop your switch code using the Switchyard test framework. Assuming you have installed Switchyard in a Python virtual environment and have activated that venv, you should run: (syenv) $ swyard -t lab_2/switchtests_to.srpy lab_2/myswitch_to.py The above command it will execute a series of test cases against your program and display whether the tests pass or fail. The file switchtests_to.srpy is the test file we provide. ✅ In the report, show the test result of your switch.(Optional) If you have written the test files yourself, show how you test the timeout mechanism. Once you get the tests to pass, you can try running your code in Mininet. Deploying Run your switch in Mininet. ✅ In Mininet, test your timeout mechanism. Prove that the timeout mechanism works with your testing procedure in the report. "},"content/ch02/lru.html":{"url":"content/ch02/lru.html","title":"Task 4: Least Recently Used","keywords":"","body":"Task 4: Least Recently Used Implementing Limited Storage for Rules Learned Real learning switches also have limited storage for forwarding rules that are learned. Implement a feature by which your learning switch can only hold a limited number of rules (implement this flexibly so that you can easily change the maximum number of rules). When your switch needs to add a new rule but there is no more space, you can consider different policies for evicting an existing rule. This time we evict the least recently used rule. General implementations of this technique require keeping \"age bits\" for rules and track the \"Least Recently Used\" rule based on age-bits. In such an implementation, every time a rule is used, the age of all other rules changes. For this functionality assume that your table can only hold 2 entries at a time. If a new entry comes and your table is full, you will remove the entry that has not been matched with a Ethernet frame destination address for the longest time. The following flowchart summarizes the algorithm described above. Your switch may have a table like: MAC Address Interface Age ab:cd:ef:fe:cd:ba interface-0 2 ... ... ... Coding Your task is to implement the logic in the above flowchart, using the Switchyard framework. You can start with copying the content of lab_2/myswitch.py to lab_2/myswitch_lru.py, which is the only file you'll need to modify. Testing Test your switch with the test file switchtests_lru.srpy we provide. ✅ In the report, show the test result of your switch.(Optional) If you have written the test files yourself, show how you test the LRU algorithm. Deploying Run your switch in Mininet. ✅ In Mininet, test the LRU algorithm. Prove that the LRU algorithm works with your testing procedure in the report. "},"content/ch02/ltv.html":{"url":"content/ch02/ltv.html","title":"Task 5: Least Traffic Volume","keywords":"","body":"Task 5: Least Traffic Volume Another Limited Storage for Rules Learned When your switch needs to add a new rule but there is no more space, we can evict the rule that has observed the least amount of network traffic in terms of numbers of packets. In addition, how you count network traffic can be done in different ways: you could also consider number of bytes, or number of application payload bytes (ignoring bytes from lower layer headers). For this functionality assume that your table can only hold 2 entries at a time. Traffic volume for an entry is the number of packets that the switch received where Destination MAC address == MAC address of entry. The following flowchart summarizes the algorithm described above. Your switch may have a table like: MAC Address Interface Traffic Volume ab:cd:ef:fe:cd:ba interface-0 15 ... ... ... Coding Your task is to implement the logic in the above flowchart, using the Switchyard framework. You can start with copying the content of lab_2/myswitch.py to lab_2/myswitch_traffic.py, which is the only file you'll need to modify. Testing Test your switch with the test file switchtests_traffic.srpy we provide. ✅ In the report, show the test result of your switch.(Optional) If you have written the test files yourself, show how you test the least traffic volume algorithm. Deploying Run your switch in Mininet. ✅ In Mininet, test the least traffic volume algorithm. Prove that the least traffic volume algorithm works with your testing procedure in the report. "},"content/ch02/faq.html":{"url":"content/ch02/faq.html","title":"FAQ","keywords":"","body":"FAQ Q: Let's assume that the table in my switch has 5 entries: [h2, h3, h4, h5, h1] where h2 is the entry that has not been matched the longest while h1 is the most recently matched entry. If a new packet (src=h6, dest=h2) arrives, how is my switch supposed to handle this packet in the LRU-based entry removal implementation (assuming that the network topology does not change)? A: Whenever you receive a new packet, you will assess the state of the switch as if you don't know about the new packet and make decisions accordingly. So when your switch receives (h6, h2), it is going to add an entry for h6 since it is not in the table. However, since the table is full (5 entries) it will need to remove the LRU entry, which is h2. So your table is going to look like this: [h3, h4, h5, h1, h6] and your switch will broadcast the incoming packets on all ports except for the incoming port since it does not have information about h2 anymore. In other words, your switch (upon receiving the packet) is not going to update the table to [h3, h4, h5, h1, h2], remove h3 and add h6 to get [h4, h5, h1, h6, h2] and output the packet on a single port, which goes to h2. Q: How do the entry removal mechanisms work? A: Note that the flow chart for timeout based mechanism does not show when/how to purge the stale entries. Your implementation will obviously handle this as well. Keep in mind that there is not a limit on the number of entries that the table can hold for this mechanism. Q: How would the table look for the following sequence of packets in the LRU-based implementation: (h1,h4), (h2,h1), (h3,h1), (h4,h1), (h5,h1), (h6.h7), (h4,h5)? (assuming that the network topology does not change) A: Assuming that the leftmost entry is the most recently used and the rightmost is the least recently used: [h1] → [h1, h2] → [h1, h3, h2] → [h1, h4, h3, h2] → [h1, h5, h4, h3, h2] → [h6, h1, h5, h4, h3] → [h5, h6, h1, h4, h3] Q: Should our switch implementations be aware of changes in the topology? A: Your learning switch has to be aware of the changes in the topology. More specifically, if the switch receives a packet from host A on its interface 1 (i1) it will record this in its table {a → i1}. Later, if the switch receives another packet from host A but on a different interface (say i2), and if the entry {a → i1} is still present, it will be updated to {a → i2}. There will not be two different entries for the same host in your table! Reflecting the topological changes in your implementations will differ slightly: Timeout-based: When updating the entry for a particular host, reset its timer to 0 (this will be equivalent to refreshing the entry for that host). LRU-based: When updating the entry for a particular host, do not update its LRU information. Traffic volume-based: When updating the entry for a particular host, keep the same traffic volume count for the host. Do not set it to 0. Q: In traffic volume based entry removal, which entry should be removed if there are two entries with the lowest traffic volume? A: You can pick an entry randomly. "},"appendix/appendix.html":{"url":"appendix/appendix.html","title":"Appendix","keywords":"","body":"Appendix Some notes and additional materials are in this chapter. "},"appendix/environment-setup.html":{"url":"appendix/environment-setup.html","title":"Environment Setup","keywords":"","body":"Environment Setup If you see here then you must be a high-end player, the instructions here will be very simple. Install Switchyard You can find instructions here, the repository of switchyard on GitHub. A quick note here for Ubuntu. git clone https://gitee.com/shellqiqi/switchyard.git sudo apt-get install libffi-dev libpcap-dev python3-dev python3-pip You can install Switchyard and the necessary related packages in an isolated Python virtual environment (\"venv\"), which is the recommended path, or in the system directories, which is often less desirable. The venv route is highly suggested, since it makes all installation \"local\" and can easily destroyed, cleaned up, and recreated. To create a new virtual environment, you could do something like the following under your workspace folder python3 -m venv syenv You can change the name syenv to whatever you'd like to name your virtual environment. Next, you need to activate the environment. The instructions vary depending on the shell you're using. On bash, the command is source ./syenv/bin/activate You'll need to replace syenv with whatever you named the virtual environment. If you're using a different shell than bash, refer to Python documentation on the venv module. Finally, install Switchyard. All the required additional libraries should be automatically installed, too. python3 -m pip install switchyard Then I suggest to exclude your virtual environment out of git tracking. Add this line in .gitignore syenv/ Install Mininet sudo apt-get install mininet Or you want to build mininet yourself. The installation guide is here. Install Wireshark sudo add-apt-repository ppa:wireshark-dev/stable sudo apt-get update sudo apt-get install wireshark You need to configure wireshark during installation. For non-superusers capturing packets, choose Yes here. Then add your user to wireshark user group to allow you capturing packets. sudo usermod -a -G wireshark $USER Other Softwares You also want to install some editors like Vim, Emacs, Visual Studio Code, Sublime and so on. But we do not install any one of them to avoiding a quarrel about the best editor. Choose your favorite one and install it yourself. Another helpful module VBoxGuestAdditions is not installed because various virtual machine hypervisors you will use. "},"appendix/about-this-repository.html":{"url":"appendix/about-this-repository.html","title":"About This Repository","keywords":"","body":"About This Repository This repository is the source code of our manual. Building You need to install gitbook-cli first. Install yarn https://classic.yarnpkg.com/en/docs/install#debian-stable Install gitbook-cli using yarn yarn global add gitbook-cli When you build this for the first time, you need to install plugins. gitbook install Then run gitbook build . docs If you want to preview, run the command below. The local website is http://localhost:4000. gitbook serve License The manual is distributed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. Repository Structure The body is placed under the content folder, and the chapters are placed in the corresponding chapter folder, starting with ch and followed by two-digit numbers. Each section and subsection is placed in the chapter folder. The pictures and other content used in the text are placed in the assets folder in the corresponding chapter folder. "}}